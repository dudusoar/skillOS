# SkillOS

**A personal operating system for AI skills that treats them as living, evolving units rather than static artifacts.**

This repository explores how skills—as introduced by Anthropic—can be created, governed, and evolved across projects through a system of meta-skills and architectural principles.

> **Status:** Early exploration. Expect iteration and incomplete pieces.

---

## The Problem

Current AI skills are static: designed once, manually updated, reused as-is. They lack mechanisms to:
- Absorb project-specific experience
- Extract general patterns from usage
- Coordinate updates across a skill library
- Separate reusable knowledge from project context

For engineers working across multiple projects, this means **reinventing patterns** and **losing accumulated wisdom**.

---

## The Idea

SkillOS introduces a **skill lifecycle with feedback loops**:

```
Create → Use → Update → Extract → Improve
    ↑_________________________________|
```

**Key components:**
- **Skills** - Reusable capabilities (testing, logging, context management)
- **Meta-skills** - Skills that operate on other skills (creation, updating, extraction)
- **Context separation** - General knowledge (in skills) vs. project context (in CLAUDE.md)
- **Contracts** - Explicit rules for what can evolve vs. what must remain stable

---

## Architectural Principles

From building and refactoring 9 skills, we've identified core principles:

### 1. Separation of Concerns

**Execution vs. Knowledge Extraction**
- `knowledge-extractor`: Analyzes patterns, generates recommendations → `EXTRACTIONS.md`
- `skill-updater`: Executes specific updates according to contracts
- User: Reviews and decides what to apply
- **Never**: Skill calling another skill programmatically

**Project Context vs. General Knowledge**
- General knowledge → Skills (reusable workflows, patterns)
- Project context → CLAUDE.md, LOG.md, ERROR_LOG.md (managed by skills)
- **Never**: Project-specific details in skill definitions

### 2. Progressive Disclosure

Keep `SKILL.md` concise (<500 lines):
- Core workflow in SKILL.md
- Detailed patterns, examples, guides in `references/`
- Scripts in `scripts/`, assets in `assets/`

**Example:** `test-writer` reduced from 618 → 244 lines (60% reduction)

### 3. Governed Evolution

Every skill has a **contract** defining:
- **Stable elements**: Core workflow, domain knowledge (don't modify)
- **Mutable elements**: References, examples, edge cases (can evolve)
- **Update rules**: What's allowed, what requires review, what's prohibited

Updates happen through `skill-updater` following contracts, not ad-hoc edits.

### 4. Context Window as Public Good

Challenge every paragraph: *"Does Claude really need this?"*
- Prefer concise examples over verbose explanations
- Move details to references, load only when needed
- Respect that SKILL.md competes for context with conversation history

---

## Skill Taxonomy

SkillOS skills fall into three categories:

### 1. Maintenance Skills
Manage project documentation and knowledge:
- **project-logger** - Maintains LOG.md (strategic decisions, milestones)
- **error-logger** - Maintains ERROR_LOG.md (tactical debugging, troubleshooting)
- **project-context-generator** - Creates CLAUDE.md (project overview, constraints)
- **skill-analyzer** - Populates CLAUDE.md sections 5-6 (available/missing skills)

### 2. Execution Skills
Apply specialized knowledge to specific tasks:
- **test-writer** - Generates comprehensive test files (pytest, jest, etc.)
- **git-workflow** - Quick reference for Git commands and workflows

### 3. Meta-Skills
Operate on skills themselves:
- **skill-contract-generator** - Defines evolution rules for skills
- **skill-updater** - Executes updates according to contracts
- **knowledge-extractor** - Analyzes projects, identifies extractable patterns

---

## Key Design Insights

### Files as Interfaces

SkillOS uses specific files as coordination points:
- **CLAUDE.md** - Global project context, maintained by `project-context-generator`, `skill-analyzer`
- **LOG.md** - Strategic project evolution, maintained by `project-logger`
- **ERROR_LOG.md** - Tactical debugging knowledge, maintained by `error-logger`
- **EXTRACTIONS.md** - Knowledge extraction recommendations, generated by `knowledge-extractor`

### Contracts Enable Evolution

Without contracts, updates fragment knowledge. With contracts:
- Clear boundaries (what changes, what doesn't)
- Safe automation (skill-updater respects rules)
- Knowledge extraction (where to look for patterns)
- Accountability (why changes were made)

### Meta-Skills Close the Loop

The lifecycle only works if meta-skills handle the transitions:
```
skill-creator (external) → Create new skill
    ↓
skill-contract-generator → Define evolution rules
    ↓
[Use skill across projects]
    ↓
skill-updater → Tactical improvements during project
    ↓
knowledge-extractor → Strategic analysis after project
    ↓
skill-updater → Apply extracted patterns
    ↓
[Improved skill for next project]
```

---

## What We've Built

**9 skills** covering the full lifecycle:

| Skill | Lines | Purpose |
|-------|-------|---------|
| project-context-generator | ~150 | Create CLAUDE.md for new projects |
| skill-analyzer | ~200 | Index available/missing skills |
| git-workflow | ~180 | Git command reference |
| project-logger | ~170 | Maintain LOG.md |
| skill-contract-generator | ~335 | Define skill contracts |
| skill-updater | ~338 | Execute skill updates |
| knowledge-extractor | ~245 | Analyze and recommend extractions |
| error-logger | ~400 | Maintain ERROR_LOG.md |
| test-writer | 244 | Generate test files |

**Lessons learned:**
- Progressive disclosure works: test-writer went from 618 → 244 lines
- Contracts prevent chaos: clear rules for what can evolve
- Skill-calling-skill is an anti-pattern: always user-mediated
- Context separation scales: CLAUDE.md stays clean, skills stay reusable

---

## Example: Test-Writer Refactoring

**Before:** 618 lines, everything in SKILL.md
- Core workflow
- Extensive examples
- Framework guides
- Mocking strategies
- Best practices

**After:** 244 lines in SKILL.md, details in references
```
test-writer/
├── SKILL.md (244 lines)
│   └── Core 8-step workflow + basic examples
└── references/
    ├── test_patterns.md (async, DB, API, file I/O)
    ├── framework_guides.md (pytest, jest, mocha)
    └── mocking_guide.md (strategies, best practices)
```

**Result:** 60% reduction, faster loading, better organization, all information preserved.

---

## Architectural Invariants

From 50+ hours of building and refactoring:

1. **Skills don't call skills** - User reviews and mediates
2. **Project context stays out of skills** - Goes in CLAUDE.md, LOG.md, ERROR_LOG.md
3. **SKILL.md stays concise** - <500 lines, use references/
4. **Contracts govern evolution** - Explicit rules, not ad-hoc edits
5. **Execution ≠ Analysis** - Separate tools for doing vs. recommending
6. **Files as interfaces** - Coordination through CLAUDE.md, LOG.md, EXTRACTIONS.md

---

## Why This Matters

**For individual practitioners:**
- Build a personal skill library that improves with use
- Extract reusable patterns from project work
- Maintain clean separation between general and project knowledge

**For AI research:**
- Concrete exploration of skill composition and evolution
- Governance patterns for multi-skill systems
- Context window optimization through progressive disclosure

**For the field:**
- Skills as living units, not static artifacts
- Feedback loops from usage to improvement
- Systems thinking for AI capabilities

---

## What This Is (and Isn't)

**Is:**
- A personal knowledge system
- A design space exploration
- An invitation to discuss alternative approaches

**Isn't:**
- A production framework
- A general-purpose platform

---

## Open Questions

1. **Skill composition**: How should skills coordinate without calling each other?
2. **Knowledge extraction**: What patterns are worth extracting vs. leaving in projects?
3. **Contract granularity**: How detailed should contracts be?
4. **Scalability**: Does this approach work with 50+ skills? 100+?
5. **Sharing**: How to share skills while preserving privacy of project context?

---

## Contributing

This is a personal exploration, but feedback is welcome:
- Architectural critique
- Alternative designs
- Real-world usage patterns
- Lessons from your own skill systems

Open an issue or discussion to share your thoughts.

---

## License

MIT - Use, adapt, or ignore as you see fit.

---

*SkillOS is an experiment in treating AI skills as first-class, evolving entities. The ideas matter more than the code.*
